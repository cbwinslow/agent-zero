import asyncio
import json
from python.helpers.tool import Tool, Response
from python.helpers.print_style import PrintStyle


class WebExploit(Tool):
    """
    Web exploitation and vulnerability assessment tool.
    Supports web application security testing, directory enumeration,
    SQL injection testing, and web vulnerability scanning.
    """

    async def execute(self, **kwargs):
        """
        Execute web exploitation operations.
        
        Supported operations:
        - dir_enum: Directory and file enumeration
        - sql_test: SQL injection testing
        - xss_test: Cross-site scripting testing
        - header_analysis: HTTP header security analysis
        - ssl_test: SSL/TLS configuration testing
        - web_crawl: Web application crawling
        """
        
        await self.agent.handle_intervention()
        
        operation = self.args.get("operation", "").lower().strip()
        target = self.args.get("target", "")
        
        if not target:
            return Response(
                message=self.agent.read_prompt(
                    "fw.tool_error.md",
                    error="Target URL is required for web exploitation"
                ),
                break_loop=False
            )
        
        # Legal warning
        warning_msg = """
⚠️  LEGAL WARNING: Web exploitation tools should ONLY be used on:
1. Systems you own
2. Systems you have written authorization to test
3. Bug bounty programs with explicit scope
Unauthorized testing is ILLEGAL and may result in criminal charges.
"""
        PrintStyle(font_color="red", padding=True, bold=True).print(warning_msg)
        
        if operation == "dir_enum":
            response = await self.directory_enumeration(target)
        elif operation == "sql_test":
            response = await self.sql_injection_test(target)
        elif operation == "xss_test":
            response = await self.xss_test(target)
        elif operation == "header_analysis":
            response = await self.header_analysis(target)
        elif operation == "ssl_test":
            response = await self.ssl_test(target)
        elif operation == "web_crawl":
            response = await self.web_crawl(target)
        else:
            response = self.agent.read_prompt(
                "fw.tool_error.md",
                error=f"Unknown operation: {operation}"
            )
        
        return Response(message=response, break_loop=False)
    
    async def directory_enumeration(self, target: str) -> str:
        """Enumerate directories and files on web server"""
        wordlist = self.args.get("wordlist", "small")  # small, medium, large
        
        code = f"""
import json
import requests
from urllib.parse import urljoin

try:
    # Small default wordlist
    common_paths = [
        'admin', 'administrator', 'login', 'wp-admin', 'wp-login.php',
        'backup', 'config', 'api', 'test', 'dev', 'staging',
        'robots.txt', 'sitemap.xml', '.git', '.env', 'phpinfo.php',
        'info.php', 'database', 'db', 'sql', 'upload', 'uploads',
        'images', 'img', 'css', 'js', 'assets', 'static',
        'readme.txt', 'changelog.txt', 'license.txt'
    ]
    
    target = '{target}'
    if not target.startswith('http'):
        target = 'http://' + target
    
    found_paths = []
    
    for path in common_paths:
        url = urljoin(target, path)
        try:
            response = requests.get(url, timeout=5, allow_redirects=False)
            if response.status_code in [200, 301, 302, 403]:
                found_paths.append({{
                    'path': path,
                    'url': url,
                    'status': response.status_code,
                    'size': len(response.content)
                }})
        except:
            pass
    
    output = {{
        'target': target,
        'total_tested': len(common_paths),
        'found': len(found_paths),
        'paths': found_paths
    }}
    
    print(json.dumps(output, indent=2))
except Exception as e:
    print(json.dumps({{'error': str(e)}}))
"""
        
        from python.tools.code_execution_tool import CodeExecution
        code_tool = CodeExecution(
            agent=self.agent,
            name="code_execution_tool",
            method=None,
            args={"runtime": "python", "code": code, "session": 0},
            message="",
            loop_data=self.loop_data
        )
        result = await code_tool.execute()
        return result.message
    
    async def sql_injection_test(self, target: str) -> str:
        """Test for SQL injection vulnerabilities (basic detection only)"""
        code = f"""
import json
import requests
from urllib.parse import urlparse, parse_qs, urlencode, urlunparse

try:
    target = '{target}'
    if not target.startswith('http'):
        target = 'http://' + target
    
    # Basic SQL injection payloads for detection only
    payloads = [
        "' OR '1'='1",
        "' OR '1'='1' --",
        "' OR '1'='1' /*",
        "admin' --",
        "' OR 1=1--",
    ]
    
    parsed = urlparse(target)
    params = parse_qs(parsed.query)
    
    results = []
    
    if params:
        for param_name in params.keys():
            for payload in payloads:
                test_params = params.copy()
                test_params[param_name] = [payload]
                
                test_query = urlencode(test_params, doseq=True)
                test_url = urlunparse((
                    parsed.scheme,
                    parsed.netloc,
                    parsed.path,
                    parsed.params,
                    test_query,
                    parsed.fragment
                ))
                
                try:
                    response = requests.get(test_url, timeout=5)
                    
                    # Look for SQL error messages
                    sql_errors = [
                        'sql syntax', 'mysql_', 'postgresql', 'sqlite',
                        'ora-', 'syntax error', 'database error'
                    ]
                    
                    has_error = any(err in response.text.lower() for err in sql_errors)
                    
                    if has_error or len(response.text) != len(requests.get(target).text):
                        results.append({{
                            'parameter': param_name,
                            'payload': payload,
                            'potentially_vulnerable': True,
                            'has_sql_error': has_error
                        }})
                except:
                    pass
    
    output = {{
        'target': target,
        'tested': len(params) * len(payloads) if params else 0,
        'potential_issues': len(results),
        'results': results
    }}
    
    if not params:
        output['note'] = 'No query parameters found to test'
    
    print(json.dumps(output, indent=2))
except Exception as e:
    print(json.dumps({{'error': str(e)}}))
"""
        
        from python.tools.code_execution_tool import CodeExecution
        code_tool = CodeExecution(
            agent=self.agent,
            name="code_execution_tool",
            method=None,
            args={"runtime": "python", "code": code, "session": 0},
            message="",
            loop_data=self.loop_data
        )
        result = await code_tool.execute()
        return result.message
    
    async def xss_test(self, target: str) -> str:
        """Test for Cross-Site Scripting vulnerabilities (detection only)"""
        code = f"""
import json
import requests
from urllib.parse import urlparse, parse_qs, urlencode, urlunparse

try:
    target = '{target}'
    if not target.startswith('http'):
        target = 'http://' + target
    
    # Basic XSS payloads for detection
    payloads = [
        '<script>alert("XSS")</script>',
        '<img src=x onerror=alert("XSS")>',
        '"><script>alert(String.fromCharCode(88,83,83))</script>',
        '<svg/onload=alert("XSS")>',
    ]
    
    parsed = urlparse(target)
    params = parse_qs(parsed.query)
    
    results = []
    
    if params:
        for param_name in params.keys():
            for payload in payloads:
                test_params = params.copy()
                test_params[param_name] = [payload]
                
                test_query = urlencode(test_params, doseq=True)
                test_url = urlunparse((
                    parsed.scheme,
                    parsed.netloc,
                    parsed.path,
                    parsed.params,
                    test_query,
                    parsed.fragment
                ))
                
                try:
                    response = requests.get(test_url, timeout=5)
                    
                    # Check if payload is reflected in response
                    if payload in response.text:
                        results.append({{
                            'parameter': param_name,
                            'payload': payload,
                            'reflected': True
                        }})
                except:
                    pass
    
    output = {{
        'target': target,
        'tested': len(params) * len(payloads) if params else 0,
        'reflected_payloads': len(results),
        'results': results
    }}
    
    if not params:
        output['note'] = 'No query parameters found to test'
    
    print(json.dumps(output, indent=2))
except Exception as e:
    print(json.dumps({{'error': str(e)}}))
"""
        
        from python.tools.code_execution_tool import CodeExecution
        code_tool = CodeExecution(
            agent=self.agent,
            name="code_execution_tool",
            method=None,
            args={"runtime": "python", "code": code, "session": 0},
            message="",
            loop_data=self.loop_data
        )
        result = await code_tool.execute()
        return result.message
    
    async def header_analysis(self, target: str) -> str:
        """Analyze HTTP security headers"""
        code = f"""
import json
import requests

try:
    target = '{target}'
    if not target.startswith('http'):
        target = 'http://' + target
    
    response = requests.get(target, timeout=10)
    
    # Security headers to check
    security_headers = {{
        'Strict-Transport-Security': 'HSTS',
        'Content-Security-Policy': 'CSP',
        'X-Frame-Options': 'Clickjacking Protection',
        'X-Content-Type-Options': 'MIME Sniffing Protection',
        'X-XSS-Protection': 'XSS Protection',
        'Referrer-Policy': 'Referrer Policy',
        'Permissions-Policy': 'Permissions Policy'
    }}
    
    present_headers = {{}}
    missing_headers = []
    
    for header, description in security_headers.items():
        if header in response.headers:
            present_headers[header] = {{
                'value': response.headers[header],
                'description': description
            }}
        else:
            missing_headers.append({{
                'header': header,
                'description': description
            }})
    
    output = {{
        'target': target,
        'status_code': response.status_code,
        'present_headers': present_headers,
        'missing_headers': missing_headers,
        'server': response.headers.get('Server', 'Not disclosed'),
        'powered_by': response.headers.get('X-Powered-By', 'Not disclosed')
    }}
    
    print(json.dumps(output, indent=2))
except Exception as e:
    print(json.dumps({{'error': str(e)}}))
"""
        
        from python.tools.code_execution_tool import CodeExecution
        code_tool = CodeExecution(
            agent=self.agent,
            name="code_execution_tool",
            method=None,
            args={"runtime": "python", "code": code, "session": 0},
            message="",
            loop_data=self.loop_data
        )
        result = await code_tool.execute()
        return result.message
    
    async def ssl_test(self, target: str) -> str:
        """Test SSL/TLS configuration"""
        code = f"""
import json
import ssl
import socket
from urllib.parse import urlparse

try:
    target = '{target}'
    if not target.startswith('http'):
        target = 'https://' + target
    
    parsed = urlparse(target)
    hostname = parsed.netloc.split(':')[0]
    port = 443
    
    context = ssl.create_default_context()
    
    with socket.create_connection((hostname, port), timeout=10) as sock:
        with context.wrap_socket(sock, server_hostname=hostname) as ssock:
            cert = ssock.getpeercert()
            protocol = ssock.version()
            cipher = ssock.cipher()
            
            output = {{
                'target': hostname,
                'protocol': protocol,
                'cipher': {{
                    'name': cipher[0] if cipher else 'Unknown',
                    'version': cipher[1] if cipher else 'Unknown',
                    'bits': cipher[2] if cipher else 0
                }},
                'certificate': {{
                    'subject': dict(x[0] for x in cert.get('subject', [])),
                    'issuer': dict(x[0] for x in cert.get('issuer', [])),
                    'version': cert.get('version', 'Unknown'),
                    'notBefore': cert.get('notBefore', ''),
                    'notAfter': cert.get('notAfter', ''),
                    'serialNumber': cert.get('serialNumber', '')
                }}
            }}
            
            print(json.dumps(output, indent=2))
except Exception as e:
    print(json.dumps({{'error': str(e)}}))
"""
        
        from python.tools.code_execution_tool import CodeExecution
        code_tool = CodeExecution(
            agent=self.agent,
            name="code_execution_tool",
            method=None,
            args={"runtime": "python", "code": code, "session": 0},
            message="",
            loop_data=self.loop_data
        )
        result = await code_tool.execute()
        return result.message
    
    async def web_crawl(self, target: str) -> str:
        """Crawl web application to discover pages"""
        max_pages = self.args.get("max_pages", "50")
        
        code = f"""
import json
import requests
from bs4 import BeautifulSoup
from urllib.parse import urljoin, urlparse
from collections import deque

try:
    target = '{target}'
    if not target.startswith('http'):
        target = 'http://' + target
    
    visited = set()
    to_visit = deque([target])
    max_pages = {max_pages}
    
    parsed_base = urlparse(target)
    base_domain = parsed_base.netloc
    
    pages = []
    
    while to_visit and len(visited) < max_pages:
        url = to_visit.popleft()
        
        if url in visited:
            continue
        
        visited.add(url)
        
        try:
            response = requests.get(url, timeout=5)
            pages.append({{
                'url': url,
                'status': response.status_code,
                'title': ''
            }})
            
            soup = BeautifulSoup(response.content, 'html.parser')
            
            # Get page title
            title = soup.find('title')
            if title:
                pages[-1]['title'] = title.get_text().strip()
            
            # Find links
            for link in soup.find_all('a', href=True):
                href = link['href']
                full_url = urljoin(url, href)
                parsed = urlparse(full_url)
                
                # Only crawl same domain
                if parsed.netloc == base_domain and full_url not in visited:
                    to_visit.append(full_url)
        except:
            pass
    
    output = {{
        'target': target,
        'pages_crawled': len(pages),
        'pages': pages[:20]  # Limit output
    }}
    
    print(json.dumps(output, indent=2))
except Exception as e:
    print(json.dumps({{'error': str(e)}}))
"""
        
        from python.tools.code_execution_tool import CodeExecution
        code_tool = CodeExecution(
            agent=self.agent,
            name="code_execution_tool",
            method=None,
            args={"runtime": "python", "code": code, "session": 0},
            message="",
            loop_data=self.loop_data
        )
        result = await code_tool.execute()
        return result.message
    
    def get_log_object(self):
        return self.agent.context.log.log(
            type="web_exploit",
            heading=f"icon://shield {self.agent.agent_name}: Web Exploitation - {self.args.get('operation', 'unknown')}",
            content="",
            kvps=self.args,
        )
